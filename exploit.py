from pwn import *
import base64 as b64
from time import sleep

def byte_xor(ba1, ba2):
    return bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])

if args.LOCAL: # Take arg from cmdline
    # Complete this if you want to test locally
    r = process("./server.py")
else:
    r = remote("141.85.224.117", 1337)  # Complete this if changed

def read_options():
    """Reads server options menu."""
    r.readuntil(b"Input:")

def get_token():
    """Gets anonymous token as bytearray."""
    read_options()
    r.sendline(b"1")
    token = r.readline()[:-1]
    return b64.b64decode(token)

def login(tag):
    """Expects bytearray. Sends base64 tag."""
    r.readline()
    read_options()
    r.sendline(b"2")
    #sleep(0.01) # Uncoment this if server rate-limits you too hard
    r.sendline(b64.b64encode(tag))
    r.readuntil(b"Token:")
    response = r.readline().strip()
    return response


### Exploit here ###

GUEST_NAME = b"Anonymous"
# Functie pentru impartit token-ul in partile componente, presupunand ca stim INTEGRITY_LEN
def parse_token(token, INTEGRITY_LEN):
    assert INTEGRITY_LEN >= 1

    encrypted_user = token[:len(GUEST_NAME)]
    SERVER_PUBLIC_BANNER = token[len(GUEST_NAME):-INTEGRITY_LEN]
    tag = token[-INTEGRITY_LEN:]

    assert len(encrypted_user) + len(SERVER_PUBLIC_BANNER) + len(tag) == len(token)

    return encrypted_user, SERVER_PUBLIC_BANNER, tag

log.info("Starting server exploit. Let's grab a user token.")

# Pas 1. Obtinem un token pentru utilizatorul anonim
token = get_token()
log.info(f"Anonymous user token: {token} of length {len(token)}.")

# Pas 2. Brute force pentru INTEGRITY_LEN. Astfel vom identifica banner-ul si dimensiunea tag-ului.
log.info("Trying to find the server banner.")
for INTEGRITY_LEN in range(len(token) - len(GUEST_NAME), 0, -1):
    encrypted_user, SERVER_PUBLIC_BANNER, tag = parse_token(token, INTEGRITY_LEN)
    log.info(f"Assuming INTEGRITY_LEN = {INTEGRITY_LEN}")
    log.info(f"Token has the following assumed components: encrypted user = {encrypted_user}, SERVER_PUBLIC_BANNER = {SERVER_PUBLIC_BANNER}, tag = {tag}")

    fake_token = b"A" * len(GUEST_NAME) + SERVER_PUBLIC_BANNER + b"B" * len(tag)
    response = login(fake_token)

    if response == b'Failed integrity check!':
        log.success(f'Found valid SERVER_PUBLIC_BANNER = {SERVER_PUBLIC_BANNER} and INTEGRITY_LEN = {INTEGRITY_LEN}')
        break
    else:
        log.failure(f'Tried fake token "{fake_token}", but SERVER_PUBLIC_BANNER was invalid.')

# Pas 3. Stim ca encrypted user = AES_E(KEY, iV) xor GUEST_NAME, deci putem calcula AES_E(KEY, IV),
# iar apoi putem genera un token pentru user-ul "Ephvuln" (userul tinta)

def byte_xor(txt, rnd):
    return bytes(a ^ b for a, b in zip(txt, rnd))

xor_key = byte_xor(encrypted_user, GUEST_NAME)
log.info(f'Computed XOR key: {xor_key}')

# Va trebui sa facem brute-force pentru tag, deoarce nu cunoastem AES_E(key, PADD(user))
TARGET_USER = b"Ephvuln"
token_prefix = byte_xor(TARGET_USER, xor_key) + SERVER_PUBLIC_BANNER

from itertools import product

# Generam toate tag-urile posibile de dimensiune INTEGIRTY_LEN folosind toate caracterele ASCII
all_chars = range(0x01, 0xff)
int_to_byte_char = lambda x: x.to_bytes(1, 'little')
possible_tags = product(map(int_to_byte_char, all_chars), repeat = INTEGRITY_LEN)

log.info("Brute-forcing tags.")
# Incercam token-ul cu toate tag-urile posibile pana unul din ele functioneaza
for tag in possible_tags:
    tag = b''.join(tag)
    token = token_prefix + tag

    log.info(f"Trying tag: {tag}")

    response = login(token)
    if b"Secret:" in response:
        log.success(f"Hacked! Data: {response}")
        break
    else:
        log.failure("The tag is not valid.")

### Exploit end ###

r.close()
